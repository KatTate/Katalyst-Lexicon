# Epic 5: Propose & Contribute — Retrospective

Date: 2026-02-12
Facilitator: Bob (Scrum Master)
Epic: 5 — Propose & Contribute
Status: Complete (2 stories done — all 34 ACs met)

## Epic Summary

Epic 5 delivered the contribution experience for Katalyst Lexicon — enabling team members to propose new terms and suggest edits to existing terms through a guided form with progressive disclosure, conversational labels, inline validation, duplicate detection, and unsaved changes protection. Both stories were implemented as sequential enhancements to a single file (`ProposeTerm.tsx`), with Story 5.1 establishing all patterns and Story 5.2 layering edit-specific behavior on top.

## Story Completion Profile

| Story | Size | ACs | Files Created | Files Modified | Notes |
|-------|------|-----|---------------|----------------|-------|
| 5.1 Proposal Form for New Terms | L | 18 | 0 | 1 | Major refactor of ProposeTerm.tsx — progressive disclosure, conversational labels, inline validation, duplicate detection, unsaved changes guard, URL pre-fill |
| 5.2 Propose Edits to Existing Terms | M | 16 | 0 | 1 | Incremental enhancement — change detection, change notes validation, duplicate suppression, auto-expand, loading state |

## Git Commit Analysis

- Total implementation commits: 8 (including process/status commits)
- Fix/correction commits: 1 (document.title + submit button disabled state — caught in code review)
- Fix-to-feature ratio: ~12.5% (acceptable)
- Most-touched file: `client/src/pages/ProposeTerm.tsx` (2 implementation commits)
- Total code changes: +492/-352 lines (net +140)
- New files created: 0
- Server/schema changes: 0 (all frontend-only)

## Codebase Health

- LSP errors: 0
- LSP warnings: 0
- TODO/FIXME/HACK markers: 0
- Net debt markers added: 0

## Code Review Findings

| # | Finding | Severity | Status |
|---|---------|----------|--------|
| 1 | Edit mode submit button not disabled until required fields valid | LOW | **Fixed** |
| 2 | Duplicate detection uses client-side name comparison | LOW | Accepted — equivalent to server-side tier filtering |
| 3 | `useSearch()` hook extraction (Epic 1 carry-forward) | LOW | Superseded for duplicate detection; still valid for SearchHero/SpotlightSearch DRY |
| 4 | `formDirtyRef` slightly overprotective in edit mode | LOW | Accepted — protective > permissive |
| 5 | Toast TOAST_REMOVE_DELAY 1000000ms globally | LOW | Pre-existing — not introduced by Epic 5 |
| 6 | `<a>` vs `<Link>` in search CTAs | LOW | Epic 1 carry-forward |
| 7 | ProposeTerm missing `document.title` | LOW | **Fixed** |

Overall Code Quality: A (0 HIGH, 0 MEDIUM, 7 LOW — 2 fixed, 3 accepted, 2 carry-forward)

## Lessons Learned

### Lesson 1: Sequential Story Stacking in a Single File Works Well

Both stories modified only `ProposeTerm.tsx`. Story 5.1 established all architectural patterns (progressive disclosure, validation, duplicate detection, unsaved changes guard), and Story 5.2 layered edit-specific behavior on top. This sequential stacking approach was effective because:
- No merge conflicts or coordination overhead
- Story 5.2 could reuse all of 5.1's patterns directly
- The component remained cohesive — edit mode is a natural extension of the new proposal flow

**Takeaway:** When an epic has 2-3 stories that all modify the same file, implement them sequentially and let each story build on the previous one's patterns. This avoids duplication and keeps the code unified.

### Lesson 2: Dual-Track Change Detection Was the Right Call

Change detection for edit mode required combining two mechanisms:
- `react-hook-form`'s `isDirty` for text fields (tracked via `form.reset()` default values)
- `JSON.stringify` array comparison for examples/synonyms (managed via separate `useState`, not form fields)

A single mechanism couldn't cover both. The `useMemo` that combines them (`hasFormChanges`) is clean and predictable. The dual-track approach was explicitly called out in the story dev notes (AC7-9, Gotcha about array fields not tracked by isDirty).

**Takeaway:** When a form mixes react-hook-form fields and external state arrays, plan for dual-track change detection from the start. Document the approach in dev notes so the reviewer understands the design choice.

### Lesson 3: Ref-Based Dirty Tracking Solves Stale Closure Problems

The unsaved changes guard needed to check form state inside `beforeunload` and `navigateWithGuard` callbacks. Using `formDirtyRef` (a ref) instead of direct state avoids stale closure issues — the callbacks always read the latest value. The `useEffect` that syncs `formDirtyRef.current` from watched values runs on every change, keeping the ref current.

**Takeaway:** When event handlers or navigation guards need to read rapidly-changing form state, use a ref to avoid stale closures. Sync the ref from a `useEffect` that watches the relevant state.

### Lesson 4: Zero Server Changes Validates API Design

Epic 5 required zero changes to `server/routes.ts`, `server/storage.ts`, or `shared/schema.ts`. The existing `POST /api/proposals` endpoint, `insertProposalSchema`, and `createProposal()` storage method handled both new and edit proposals without modification. This validates the API design from earlier epics — the schema was flexible enough (with `type`, `termId`, `changesSummary` fields) to accommodate the full contribution workflow.

**Takeaway:** A well-designed schema with enumerated types and optional foreign keys can support complex workflows without modification. Invest in schema design upfront to avoid API churn later.

### Lesson 5: Code Review Catches Consistency Gaps

The code review caught that the submit button was disabled until required fields were filled in new proposal mode, but not in edit mode. This was a subtle inconsistency — functionally the form still validated on submit, but the visual feedback was different between modes. A single-character fix (`!isEditMode && ` removal) resolved it.

**Takeaway:** Code review is valuable even for all-LOW findings. Consistency gaps between modes (new vs. edit) are easy to miss during development because you test each mode separately.

## Epic 4 Retrospective Follow-Through

| # | Action Item | Status | Evidence |
|---|------------|--------|----------|
| 1 | Mark Epic 4 as "done" in sprint-status.yaml | ✅ Done | sprint-status.yaml shows `epic-4: done` |
| 2 | Add `getPrinciplesWithCounts()` to storage layer | ⏳ Deferred | Not needed for Epic 5 — no principles changes |
| 3 | Update API client types to include `linkedTermCount` | ⏳ Deferred | Not needed for Epic 5 |
| 4 | Extract `useSearch()` hook (Epic 1 carry-forward) | ❌ Not addressed | Duplicate detection used a different pattern (single `api.terms.search()` call on blur) — hook extraction is still valid for SearchHero/SpotlightSearch DRY but was not needed for Epic 5's duplicate detection |
| 5 | Replace `<a>` with `<Link>` in search empty state CTAs | ❌ Not addressed | Carry-forward — these CTAs are in SearchHero/SpotlightSearch, not in ProposeTerm |
| 6 | Clean up identity CSS/component overrides | ⏳ Deferred | Not needed for Epic 5 |

**Follow-through rate:** 1 of 6 completed, 3 appropriately deferred (not relevant to Epic 5), 2 not addressed (carry-forward to cleanup sprint).

**Note on Actions #4 and #5:** These were scheduled "before Epic 5" in the Epic 4 retro. In practice, Epic 5's duplicate detection used a different approach (`api.terms.search()` call on blur, client-side filtering) that didn't require the `useSearch()` hook. The hook extraction remains valuable as a DRY improvement for SearchHero/SpotlightSearch but is not blocking. The `<a>` vs `<Link>` issue is cosmetic and confined to search empty state CTAs — it doesn't affect Epic 5's functionality.

## Retrospective Discussion Summary

**Participants:** Bob (Scrum Master), Alice (Product Owner), Charlie (Senior Dev), Dana (QA Engineer), User (Project Lead)

Bob (Scrum Master): "Epic 5 was clean — 2 stories, 34 ACs, zero server changes, zero new files. The sequential stacking approach worked well for a single-file epic."

Alice (Product Owner): "The contribution experience is complete. Team members can now propose new terms and suggest edits. This unblocks Epic 6 (Review & Approve) which needs proposals to review."

Charlie (Senior Dev): "The dual-track change detection was the trickiest part. react-hook-form's isDirty doesn't track external state arrays, so we needed the JSON.stringify comparison alongside it. But the dev notes called this out explicitly, so it wasn't a surprise."

Dana (QA Engineer): "E2E testing covered 23 steps across both modes. The unsaved changes guard, duplicate detection, and change detection all worked correctly. No bugs found in testing."

Bob (Scrum Master): "Code review found 7 LOW issues — 2 fixed (document.title, submit button consistency), 3 accepted, 2 carry-forward from earlier epics. Clean overall."

**User Assessment:** Everything looked smooth. Team consensus to proceed to Epic 6 (Review & Approve).

**Team Agreements:**
- Continue sequential story stacking for single-file epics
- Document dual-track patterns explicitly in dev notes when mixing form state and external state
- Use ref-based dirty tracking for navigation guards and event handlers
- Carry forward `useSearch()` hook extraction and `<a>` → `<Link>` fixes to a cleanup sprint

## Readiness Assessment for Next Epic

### Epic 6: Review & Approve (4 stories: 6.1-6.4)

- **Status:** backlog
- **Depends on:** Epic 5 (proposals to review) — ✅ Complete
- **Stories:**
  - 6.1 Proposal Review Queue — list pending proposals with filters
  - 6.2 Proposal Review and Decision — approve/reject/request changes
  - 6.3 Proposal Audit Trail — full history of proposal decisions
  - 6.4 Proposer Revision Flow — proposer responds to feedback
- **Reuses from Epic 5:** Proposal data model, `api.proposals` client methods, toast patterns
- **New architectural territory:** Approval state machine (pending → approved/rejected/changes_requested → revised), atomic term creation/update on approval, audit trail logging
- **Risk:** Medium. The approval workflow has complex state transitions. Atomic operations (approve proposal → create/update term in one transaction) need careful implementation.
- **Preparation needed:**
  - Review proposal schema fields (`status`, `reviewedBy`, `reviewComment`, `reviewedAt`)
  - Check if `server/storage.ts` has approval-related methods
  - Plan state machine transitions and ensure schema supports all states

## Outstanding Tech Debt

| # | Item | Severity | Source | When to Address |
|---|------|----------|--------|-----------------|
| 1 | `GET /api/principles` bypasses storage layer | MEDIUM | Epic 4 Finding 3 | Before storage layer refactoring |
| 2 | Extract `useSearch()` hook for DRY | LOW | Epic 1 carry-forward | Cleanup sprint |
| 3 | Replace `<a>` with `<Link>` in search CTAs | LOW | Epic 1 carry-forward | Cleanup sprint |
| 4 | `PrincipleWithCount` type assertion | LOW | Epic 4 Finding 2 | When updating API client types |
| 5 | Toast TOAST_REMOVE_DELAY 1000000ms | LOW | Pre-existing | Cleanup sprint |

## Action Items

| # | Action | Priority | When |
|---|--------|----------|------|
| 1 | Update sprint-status.yaml with Epic 5 done | High | ✅ Already done |
| 2 | Begin Epic 6 story creation (6.1 Proposal Review Queue) | High | Next session |
| 3 | Review proposal schema for approval state machine fields | Medium | Before Epic 6 development |
| 4 | Consolidate carry-forward tech debt (useSearch hook, `<a>` → `<Link>`, toast delay) into cleanup sprint | Low | After Epic 6 |

## Epic 5 Metrics Summary

| Metric | Value |
|--------|-------|
| Stories completed | 2 |
| Total ACs | 34 (all satisfied) |
| New components created | 0 |
| Files modified | 1 (ProposeTerm.tsx) |
| Server changes | 0 |
| Schema changes | 0 |
| Net lines changed | +140 (492 additions, 352 deletions) |
| Code review findings | 7 total (0 HIGH, 0 MEDIUM, 7 LOW — 2 fixed) |
| Bugs caught in review | 0 (2 consistency improvements) |
| E2E test steps passed | 23/23 |
| Tech debt items | 0 new (5 carry-forward from previous epics) |
